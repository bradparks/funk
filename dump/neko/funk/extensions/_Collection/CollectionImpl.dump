private class funk.extensions._Collection.CollectionImpl{
	static _new(inline method) : collection : funk.extensions.Collections<funk.extensions.Collection.T> -> funk.extensions.Collections<funk.extensions.Collection.T>

	 = function(collection:funk.extensions.Collections<funk.extensions.Collection.T>) = {
		return collection;
	};

	static public iterator(inline method) : this : funk.extensions.Collections<funk.extensions.Collection.T> -> Iterator<funk.extensions.Collection.T>

	 = function(this1:funk.extensions.Collections<funk.extensions.Collection.T>) = {
		return this1.iterator();
	};

	static public size(inline method) : this : funk.extensions.Collections<funk.extensions.Collection.T> -> Int

	 = function(this1:funk.extensions.Collections<funk.extensions.Collection.T>) = {
		return this1.size();
	};

	static public fromArray<T : fromArray.T>(inline method) : array : Array<fromArray.T> -> funk.extensions.Collection<fromArray.T>

	 = function(array:Array<fromArray.T>) = {
		return cast {iterator : array.iterator,size : function() = {
			return array.length;
		}};
	};

	static public toFoldable<T : toFoldable.T>(inline method) : collection : funk.extensions.Collections<toFoldable.T> -> funk.extensions.Foldable<toFoldable.T>

	 = function(collection:funk.extensions.Collections<toFoldable.T>) = {
		var foldable0 = cast collection;
		var foldable1 = {foldLeft : {
			var _e = foldable0;
			function(value:toFoldable.T,func:toFoldable.T -> toFoldable.T -> toFoldable.T) = {
				return {
					var result = value;
					var iterator = _e.iterator();
					while ((iterator.hasNext())) {
						haxe.Log.trace(result,{fileName : "CollectionFoldable.hx",lineNumber : 19,className : "funk.types._CollectionFoldable.CollectionFoldableImpl",methodName : "foldLeft"});
						result = func(result,iterator.next());
					};
					funk.extensions._Option.OptionImpl._new(if ((result == null))funk.extensions.Options.None else funk.extensions.Options.Some(result)));
				};
			};
		},foldRight : {
			var _e = foldable0;
			function(value:toFoldable.T,func:toFoldable.T -> toFoldable.T -> toFoldable.T) = {
				return {
					var result = value;
					var iterator = _e.iterator();
					var reverse = {
						var p = iterator;
						var stack = {
							var stack = [];
							for (i in p) stack.push(i);
							stack;
						};
						stack.reverse();
						stack.iterator();
					};
					while ((reverse.hasNext())) {
						haxe.Log.trace(result,{fileName : "CollectionFoldable.hx",lineNumber : 32,className : "funk.types._CollectionFoldable.CollectionFoldableImpl",methodName : "foldRight"});
						result = func(result,reverse.next());
					};
					funk.extensions._Option.OptionImpl._new(if ((result == null))funk.extensions.Options.None else funk.extensions.Options.Some(result)));
				};
			};
		}};
		return foldable1;
	};

	static public toString<T : toString.T>(inline method) : collection : funk.extensions.Collections<toString.T> -> String

	 = function(collection:funk.extensions.Collections<toString.T>) = {
		return "Collection(" + Std.string(collection) + ")";
	};

}